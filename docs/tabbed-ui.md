# TurboFrames: タブメニュー

## ウェブサイトのUIは「枠」が重要

ウェブサイトのUIは「枠」で作られることが多い。

例えばインタラクティブなUIの代表である「モーダル」は、画面上に「枠」を出現させ、その中にUI要素を詰めていると考えることができる。「ポップアップダイアログ」や「ドロップダウンメニュー」もそうである。 タブメニューも、どのタブをクリックするかによって「枠」の中身を切り替えるものである。

このように「枠」の表示・非表示を切り替え、その中身を自在に出し入れできれば、かなり多くのウェブUI要素を作ることができる。TurboFramesの役割はこれを実現するものである。

## TurboFramesは「枠」のデータをサーバから取ってきて、はめ込む

「枠」そのものは簡単なJavaScriptで表示・非表示を切り替えることができる。Reactの場合は表示・非表示用のステートを作って、ステートに応じて「枠」コンポーネントをレンダリングするかどうかを切り替えるだろう。あるいは `style`の`display:none`を切り替えるだけで表示・非表示を切り替えられる。

したがって「枠」の内容がすでにブラウザにあればシンプルである。 問題は「枠」の内容をサーバから取得するところである。

TurboFramesはここを担う。

## タブメニューでのTurboFrames

タブメニューをTurboFramesで実装した場合の処理の流れは下記の通りである。

1. タブメニューのボタン(`Products`)ボタンがクリックされる(`a tag`)
2. `a tag`をクリックすると通常は画面遷移をするが、それを傍受して非同期で`products`のエンドポイントにGETリクエストを飛ばす
3. サーバは適切なレスポンスを返す。この中にはTurboFrames「枠」に差し込むべきHTMLが含まれる。
4. レスポンスを適切なTurboFrames「枠」に差し込む

まず最初にエンドポイントからHTMLを取得しに行き、それをTurboFrameに差し込むというイメージである。

## Reactだったらどうするか

比較のために、Reactで作った場合の動作も確認する

1. タブメニューのボタン(`Products`)がクリックされる
2. ボタンの`onClick`属性で指定されたハンドラー関数を呼び出す。このハンドラー関数により、どのタブが指定されているかのステート(`selectedTab`)を更新する
3. 再レンダリングが行われ、`selectedTab`の内容に応じて、タブの中身のコンポーネントを切り替える(`Users` => `Products`)
4. `Products`コンポーネントがレンダリングされる
5. `Products`コンポーネントはこの時点ではサーバからのデータを持っていない。レンダリング後に`useEffect`の中が実行され、サーバからデータが取得される。このデータで`Products`のステートが更新される
6. 再レンダリングが実行され、`Products`コンポーネントにサーバのデータが正しく表示される

Reactの場合は、まずタブの中身を適切なコンポーネントに入れ替える（ブラウザの中で）。そして後から`useEffect`でそのコンポーネントのデータをサーバから取得する。

## 開発の流れ

TurboFramesの場合は、タブの中に差し込むコンテンツは独立したエンドポイントである。ブラウザをそのURLに向ければ、そのコンテンツがそのまま表示される。

このため、開発時にはまずこのエンドポイントのHTMLレスポンスを作るところから始める。その後にTurboFramesの枠をはめて、また呼び出し側で受け入れるためのTurboFramesを設置する。最後にこのエンドポイントに向かう`a tag`を作る(このタグの属性として`data-turbo-frame`で対象のTurboFrameのIDを指定する)

## TurboFramesの考え方

Reactの処理は`a tag`と無関係であり、`a tag`は全く使われない。一方でTurboFramesの場合は`a tag`の機能を拡張しているだけに見える。実際ブラウザのネイティブな機能で、`a tag`に`target="_blank"`属性を付与すると、レスポンスは新規タブに表示されるが、TurboFrameの動きはこれに酷似している。

実際TurboFramesについて勉強を進めると、TurboFrameの中身は別タブだと考えた方がわかりやすいケースも出てくる。

これを反映させて、TurboFrameのエンドポイントをブラウザの検索バーに表示させ、ブラウザの履歴に保存したり、ブックマークしたり、バックボタンを効かせたりもできる。今回のデモでもそのようになっているので、URLが変わること、バックボタンが効くことなどを確認できる。

Reactの場合はタブの中身とURLは完全に独立した考えになっているので、このような動きにはならない。app routerのネスト化されたルートを使えば、画面の一部とURLを連動できるので、可能になってくる。

## リンクのprefetch

TurboFramesは`a tag`を拡張しているだけなので、通常通りにprefetchが機能する。そのためタブをクリックしたときのレスポンスは良好である。

一方でReactの場合は、タブは`Link tag`ではない。そのためprefetchは機能した。コンポーネントを切り替えるところまではブラウザ内で処理されるので瞬間的だが、`useEffect`内の`fetch`のレスポンスまではどうしても表示を待たなければならない。

結果としてprefetchを使用できるHotwireの方が、よりヌルサクになる。

